<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>用 Bevy 游戏引擎编写贪吃蛇（译） - huangjj27&#x27;s Tech blog</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="tauri-single-instance-bug-dangling.html">由 tauri 单例模式 bug “意外修复” 发现的 dangling</a></li><li class="chapter-item expanded "><a href="load-wasm-mistake.html">尝试在单 HTML 文件中嵌入 WASM 模块的错误操作</a></li><li class="chapter-item expanded "><a href="reservoir.html">蓄水池算法改进 - 面向抽奖场景保证等概率性</a></li><li class="chapter-item expanded "><a href="interview.html">记一次面试</a></li><li class="chapter-item expanded "><a href="snake-with-bevy.html" class="active">用 Bevy 游戏引擎编写贪吃蛇（译）</a></li><li class="chapter-item expanded "><a href="rust-safe-apps-51.html">Rust 安全应用开发51条</a></li><li class="chapter-item expanded "><a href="rust-tianhe-ii.html">在天河二号上配置 Rust 运行环境</a></li><li class="chapter-item expanded "><a href="rust-patterns/intro.html">设计模式在 Rust 中的实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-patterns/builder.html">构建器（Builder）模式</a></li><li class="chapter-item expanded "><a href="rust-patterns/abstract-factory.html">抽象工厂（Abstract Factory）模式</a></li></ol></li><li class="chapter-item expanded "><a href="rust-mirror.html">Rust 镜像</a></li><li class="chapter-item expanded "><a href="rust-ffi.html">在 WSL 中学习 Rust FFI</a></li><li class="chapter-item expanded "><a href="wasi/intro.html">WASI探索</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wasi/wasi_and_wasmtime.html">WASI简介与Wasmtime配置</a></li><li class="chapter-item expanded "><a href="wasi/wasi_guess.html">WASI版猜数字</a></li></ol></li><li class="chapter-item expanded "><a href="number_theory/intro.html">初等数论自我探索</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="number_theory/if_2n-p_is_divided_by_p.html">若质数p不能整除偶数2n，则p不整除2n-p</a></li><li class="chapter-item expanded "><a href="number_theory/single-composite-divsion.html">整数和它两倍间的合数的性质</a></li><li class="chapter-item expanded "><a href="number_theory/goldbachs-conjecture.html">用初等数论探索哥德巴赫猜想</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="resume.html">关于我</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">huangjj27&#x27;s Tech blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/huangjj27/huangjj27.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.bevy_img {
    max-height: 400px;
    max-width: 80vw;
    margin-left: auto;
    margin-right: auto;
    display: block;
}
</style>
<h1 id="用-bevy-游戏引擎编写贪吃蛇译"><a class="header" href="#用-bevy-游戏引擎编写贪吃蛇译">用 <code>Bevy</code> 游戏引擎编写贪吃蛇（译）</a></h1>
<blockquote>
<p>原文：<a href="https://mbuffett.com/posts/bevy-snake-tutorial/#0.3">https://mbuffett.com/posts/bevy-snake-tutorial/#0.3</a></p>
</blockquote>
<p><a href="https://bevyengine.org/">Bevy</a> 最近普及开来了，但是相关学习资料还是很少。这篇文章尝试提供 Bevy 官方书（The Bevy book）的下一步学习。最后产品看起来像这样：</p>
<video autoplay="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/game_over.mp4" type="video/mp4">
</video>
<p>这大约是 300 行 Rust 代码；也需要花点时间深入。如果你想快进到成品代码，请点 <a href="https://github.com/marcusbuffett/bevy_snake/tree/tutorial">这里</a>。每一个小节开头都有一份代码差异，这应该会在你不是很清晰哪里需要插入代码的时候更加清晰一点。</p>
<h2 id="新的空的-bevy-应用"><a class="header" href="#新的空的-bevy-应用">新的空的 Bevy 应用</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/174c226">点击查看差异</a></p>
</blockquote>
<p>我们现在像 Bevy 官方书那样开始，整一个啥都不干的应用。运行 <code>cargo new bevy-snake</code>, 然后把以下代码放到你的 <code>main.rs</code> ：</p>
<pre><code class="language-rs">use bevy::prelude::*;

fn main() {
    App::build().run();
}
</code></pre>
<p>我们还需要在 <code>Cargo.toml</code> 将 Bevy 作为依赖添加，因为我（原文作者，下同）知道这个教程之后要干嘛，我们现在也提前添加 <code>rand</code>库吧。</p>
<pre><code class="language-toml">// ...

[dependencies]
bevy = &quot;0.3.0&quot;
rand = &quot;0.7.3&quot;
</code></pre>
<h2 id="创建窗口"><a class="header" href="#创建窗口">创建窗口</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/3f7c30b">点击查看差异</a></p>
</blockquote>
<p>我们现在要创建一个2D游戏，需要很多不同的系统；用来创建窗口的，用来做渲染循环的，用来处理输出的，用来处理精灵（sprites)的，等等。幸运的是，Bevy的默认插件给了我们以上所有选项：</p>
<pre><code class="language-rs">fn main() {
    App::build().add_plugins(DefaultPlugins).run();
}
</code></pre>
<p>然而 Bevy 的默认插件不包括摄像机（camera），所以我们来插入一个 2D 摄像机，只要我们创建我们第一个系统就可以设置了：</p>
<pre><code class="language-rs">fn setup(mut commands: Commands) {
    commands.spawn(Camera2dComponents::default());
}
</code></pre>
<p><a href="https://docs.rs/bevy_ecs/0.2.1/bevy_ecs/struct.Commands.html"><code>Cammands</code></a> 通常用来排列命令，来更改游戏世界与资源。在这里，我们创建一个带有 2D 摄像机组件的实体。为Bevy的魔法做点准备吧：</p>
<pre><code class="language-rs">App::build()
    .add_startup_system(setup.system()) // &lt;--
    .add_plugins(DefaultPlugins)
    .run();
</code></pre>
<p>我们需要做的只是在我们的函数是调用 <code>.system()</code>，然后 Bevy 会神奇地在启动地时候调用 <code>commands</code> 参数。再运行一次 app， 你应该能看到一个像这样的空窗口：</p>
<p><img src="https://mbuffett.com/bevy_snake/new_pics/empty_window.png" alt="" /></p>
<h2 id="开始编写一条蛇"><a class="header" href="#开始编写一条蛇">开始编写一条蛇</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/baaefcc">点击查看差异</a></p>
</blockquote>
<p>我们来写个蛇头放在窗口上吧。我们先定义几个结构体：</p>
<pre><code class="language-rs">struct SnakeHead;
struct Materials {
    head_material: Handle&lt;ColorMaterial&gt;,
}
</code></pre>
<p><code>SnakeHead</code> 仅仅是一个空结构体，我们会把它当作一个组件来使用，它就是像某种标签，我们会放到一个实体上，之后我们能通过查询带有 <code>SnakeHead</code> 组件的实体来找到这个实体。像这样的空结构体在 Bevy 中是一种常见的模式，组件经常不需要他们自己的任何状态。 <code>Materials</code> 以后会变成一种资源，用来存储我们给蛇头使用的材质，也会用来存储蛇身和食物的材质。</p>
<p><code>head_material</code> 句柄应该在游戏设置的时候就应该创建好，所以我们接下来要做的是，修改我们的 <code>setup</code> 函数：</p>
<pre><code class="language-rs">fn setup(mut commands: Commands, mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;) {
    commands.spawn(Camera2dComponents::default());
    commands.insert_resource(Materials {
        head_material: materials.add(Color::rgb(0.7, 0.7, 0.7).into()),
    });
}
</code></pre>
<blockquote>
<p><strong>注意：</strong> Bevy要求在注册系统时按照特定的顺序。命令（Commands） -&gt; 资源（Resources） -&gt; 组件（Components）/查询（Queries）。如果你在弄乱一个系统之后获得一个神秘的编译时错误，请检查你的顺序。</p>
</blockquote>
<p><code>materials.add</code> 会返回 <code>Handle&lt;ColorMaterial&gt;</code>。我们创建了使用这个新建 handle 的 <code>Materials</code> 结构体。之后，我们尝试访问类型为 <code>Materials</code> 的资源， Bevy会找到我们这个结构体。现在我们来在新的系统里创建我们的蛇头实体，然后你会看到我们如何使用前述资源的：</p>
<pre><code class="language-rs">fn game_setup(mut commands: Commands, materials: Res&lt;Materials&gt;) {
    commands
        .spawn(SpriteComponents {
            material: materials.head_material.clone(),
            sprite: Sprite::new(Vec2::new(10.0, 10.0)),
            ..Default::default()
        })
        .with(SnakeHead);
}
</code></pre>
<p>现在我们有了新的系统，它会寻找类型为 <code>Materials</code> 的资源。它也会创建（spawn）一个新实体，带有 <code>SpriteComponents</code> 和 <code>SnakeHead</code> 组件。为了创建 <code>SpriteComponents</code>, 我们将我们之间创建的颜色的 handle 传入，并且给精灵 10x10 的大小。我们将这个系统添加到我们 app 的构建器：</p>
<pre><code class="language-rs">.add_startup_system(setup.system())
.add_startup_stage(&quot;game_setup&quot;) // &lt;--
.add_startup_system_to_stage(&quot;game_setup&quot;, game_setup.system()) // &lt;--
</code></pre>
<p>我们需要一个新的场景而不是再一次调用 <code>add_startup_system</code> 的原因是，我们需要使用在 <code>setup</code> 函数中插入的资源。这次运行后，你应该在屏幕中央看到蛇头：</p>
<p><img src="https://mbuffett.com/bevy_snake/new_pics/snake_pixel.png" alt="" /></p>
<p>好了，可能我们叫它“蛇头”有点过了，你可以看到一个 10x10 的白色精灵。</p>
<h2 id="移动小蛇"><a class="header" href="#移动小蛇">移动小蛇</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/fde99c9">点击查看差异</a></p>
</blockquote>
<p>如果小蛇不运动，那么游戏很无趣，所以我们先让蛇头动起来。我们之后再担心输入，现在我们的目标是让蛇头移动。所以我们来创建一个系统来移动所有的蛇头：</p>
<pre><code class="language-rs">fn snake_movement(mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;) {
    for (_head, mut transform) in head_positions.iter_mut() {
        *transform.translation.y_mut() += 2.;
    }
}
</code></pre>
<p>这里有个新概念， <code>Query</code> 类型。我们用它来迭代所有拥有 <code>SnakeHead</code> 组件以及 <code>Transform</code> 组件的实体。我们不需要担心实际上如何创建查询类型， bevy 会帮我们创建好并用它调用我们的函数，算是 ECS 魔法的一部分。所以我们来加上这个系统， 然后看看会发生些什么：</p>
<pre><code class="language-rs">.add_startup_system_to_stage(&quot;game_setup&quot;, game_setup.system())
.add_system(snake_movement.system()) // &lt;--
.add_plugins(DefaultPlugins)
</code></pre>
<p>这是我们看到的，一头蛇移出了屏幕：</p>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/moving_up.mp4" type="video/mp4">
</video>
<p>你可能再思考 Transform 组件。当我们生成 <code>SnakeHead</code> 时，我们并没有给它 <code>Transform</code>，所以我们怎么就能找到一个同事拥有 <code>SnakeHead</code> 和 <code>Transform</code> 组件的实体呢？实际上 <code>SpriteComponents</code> 是一捆组件。就 <code>SpriteComponents</code> 来说，它包含了 <code>Transform</code> 组件，以及一堆其他组件（如 <code>Sprite</code>, <code>Mesh</code>, <code>Draw</code>, <code>Rotation</code>, <code>Sale</code>）。</p>
<h2 id="控制小蛇"><a class="header" href="#控制小蛇">控制小蛇</a></h2>
<p>我们来修改我们小蛇的移动系统，使得我们可以控制小蛇：</p>
<pre><code class="language-rs">fn snake_movement(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut head_positions: Query&lt;With&lt;SnakeHead, &amp;mut Transform&gt;&gt;,
) {
    for mut transform in head_positions.iter_mut() {
        if keyboard_input.pressed(KeyCode::Left) {
            *transform.translation.x_mut() -= 2.;
        }
        if keyboard_input.pressed(KeyCode::Right) {
            *transform.translation.x_mut() += 2.;
        }
        if keyboard_input.pressed(KeyCode::Down) {
            *transform.translation.y_mut() -= 2.;
        }
        if keyboard_input.pressed(KeyCode::Up) {
            *transform.translation.y_mut() += 2.;
        }
    }
}
</code></pre>
<p>留意到我们的查询 <code>Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;</code> 改为了 <code>Query&lt;With&lt;SnakeHead, &amp;mut Transform&gt;&gt;</code>，其实当前版本没有必要更改，旧的查询依然能很好地工作。我想，第一个系统的类型签名可能简单些，但是现在我们用正确的方式编写类型。这写法更正确是因为我们其实不需要 SnakeHead 组件。所以 <code>With</code> 类型允许我们说，“我们需要那些有蛇头的实体，但是我不关心蛇头组件，只给我 transform 组件就好。”每个系统访问的组件越少，bevy就能并行越多的系统。例如，如果另外一个系统正在修改 <code>SnakeHead</code> 组件，那这个系统旧不能在用旧写法的时候并行了。</p>
<p>现在，我们能控制小蛇了，尽管它动起来不那么像蛇：</p>
<video autoplay="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/game_over.mp4" type="video/mp4">
</video>
<h2 id="码格子"><a class="header" href="#码格子">码格子</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/d1f4225">点击查看差异</a></p>
</blockquote>
<p>到现在我们一直在用窗口的坐标，但这种方法只能在 (0, 0) 坐标在窗口正中央，并且单位是像素的时候有效。贪吃蛇游戏通常用格子，所以如果我们把我们的贪吃蛇设置成 10x10，那我们的窗口会 <strong>真的</strong> 很小。我们让日子变得轻松些吧，我们选择用我们自己的位置和尺寸。然后，我们用系统来处理变换到窗口的坐标。</p>
<p>我们先定义格子为 10x10。在程序文件开头定义如下变量：</p>
<pre><code class="language-rs">const ARENA_WIDTH: u32 = 10;
const ARENA_HEIGHT: u32 = 10;
</code></pre>
<p>以及我们用于处理位置/尺寸的结构体：</p>
<pre><code class="language-rs">#[derive(Default, Copy, Clone, Eq, PartialEq, Hash)]
struct Position {
    x: i32,
    y: i32,
}

struct Size {
    width: f32,
    height: f32,
}
impl Size {
    pub fn square(x: f32) -&gt; Self {
        Self {
            width: x,
            height: x,
        }
    }
}
</code></pre>
<p>相对直接地，有一个辅助方法来获取一个有相等长宽的 <code>Size</code>. Position 派生了一些很有用的 trait，所以我们不必不停地回顾这个结构体。 <code>Size</code> 可以仅仅包含一个浮点数，因为所有的对象最后都有相等的长度和宽度，但是我给它长度和宽度好像有点不对。我们现在把这些组件添加到我们生成的蛇头上：</p>
<pre><code class="language-rs">commands
    .spawn(SpriteComponents {
        material: materials.head_material.clone(),
        sprite: Sprite::new(Vec2::new(10.0, 10.0)),
        ..Default::default()
    })
    .with(SnakeHead)
    .with(Position { x: 3, y: 3 }) // &lt;--
    .with(Size::square(0.8)); // &lt;--
</code></pre>
<p>这些组件暂时不做任何事情，我们现在就来将我们的尺寸映射到精灵的尺寸：</p>
<pre><code class="language-rs">fn size_scaling(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Size, &amp;mut Sprite)&gt;) {
    let window = windows.get_primary().unwrap();
    for (sprite_size, mut sprite) in q.iter_mut() {
        sprite.size = Vec2::new(
            sprite_size.width / ARENA_WIDTH as f32 * window.width() as f32,
            sprite_size.height / ARENA_HEIGHT as f32 * window.height() as f32,
        );
    }
}
</code></pre>
<p>这个尺寸变换逻辑是这样的：如果某个对象有一个单位格子宽度，格子宽40，然后窗口现在 400px 宽，那么它应该有10哥宽度。下面我们做位置系统：</p>
<pre><code class="language-rs">fn position_translation(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Position, &amp;mut Transform)&gt;) {
    fn convert(pos: f32, bound_window: f32, bound_game: f32) -&gt; f32 {
        let tile_size = bound_window / bound_game;
        pos / bound_game * bound_window - (bound_window / 2.) + (tile_size / 2.)
    }
    let window = windows.get_primary().unwrap();
    for (pos, mut transform) in q.iter_mut() {
        transform.translation = Vec3::new(
            convert(pos.x as f32, window.width() as f32, ARENA_WIDTH as f32),
            convert(pos.y as f32, window.height() as f32, ARENA_HEIGHT as f32),
            0.0,
        );
    }
}
</code></pre>
<!-- TODO: 翻译结果混乱，需要重新翻译 -->
<p>位置变换：如果项目的 X 坐标在我们的系统中是 5，宽度是 10，并且窗口宽度是200，那么坐标应该是 5/10 * 200 - 200 / 2。我们减去一半的窗口宽度，因为我们的做消息是从左下角开始，然后替换到正中央。然后我们再加上半个格子，因为我们想要我们精灵的左下角对齐格子的左下角，而不是精灵中心对齐。</p>
<p>然后我们把这些系统加到我们的应用构建器上：</p>
<pre><code class="language-rs">.add_system(snake_movement.system())
.add_system(position_translation.system()) &lt;--
.add_system(size_scaling.system()) &lt;--
.add_plugins(DefaultPlugins)
.run();
</code></pre>
<blockquote>
<p><strong>注意：</strong> 现在最明显的问题是小蛇被压扁了。另外一个问题是我们破环了我们的输入处理。我们先修复输入处理，然后我们得记得回来处理我们被压扁的小蛇，把它恢复原状。</p>
</blockquote>
<p><img src="https://mbuffett.com/bevy_snake/new_pics/squished_snake.png" alt="" /></p>
<h2 id="使用我们的格子"><a class="header" href="#使用我们的格子">使用我们的格子</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/0f39c51">点击查看差异</a></p>
</blockquote>
<p>我们现在配置好了格子坐标，现在我们需要更新我们的 <code>snake_movement</code> 系统。之前我们使用 <code>Transform</code> 的地方，现在替换成 <code>Position</code>：</p>
<pre><code class="language-rs">fn snake_movement(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut head_positions: Query&lt;With&lt;SnakeHead, &amp;mut Position&gt;&gt;,
) {
    for mut pos in head_positions.iter_mut() {
        if keyboard_input.pressed(KeyCode::Left) {
            pos.x -= 1;
        }
        if keyboard_input.pressed(KeyCode::Right) {
            pos.x += 1;
        }
        if keyboard_input.pressed(KeyCode::Down) {
            pos.y -= 1;
        }
        if keyboard_input.pressed(KeyCode::Up) {
            pos.y += 1;
        }
    }
}
</code></pre>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/moving_grid.mp4" type="video/mp4">
</video>
<h2 id="调整窗口大小1"><a class="header" href="#调整窗口大小1">调整窗口大小<sup class="footnote-reference"><a href="#1">1</a></sup></a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/dce7a53">点击查看差异</a></p>
</blockquote>
<p>我们上一步中的小蛇被压扁了，是因为默认的窗口尺寸并不是方形的，然而我们的格子是，所以我们每个格坐标会宽度长于高度。我们修复它最简单的方法，是在构建 app 的时候创建一个 <code>WindowDescriptor</code> 资源：</p>
<pre><code class="language-rs">    App::build()
        .add_resource(WindowDescriptor { // &lt;--
            title: &quot;Snake!&quot;.to_string(), // &lt;--
            width: 200,                 // &lt;--
            height: 200,                // &lt;--
            ..Default::default()         // &lt;--
        })
        .add_startup_system(setup.system())
</code></pre>
<p>同时，我们改一下背景颜色，插入这个 <code>use</code> 语句来引入 <code>ClearColor</code> 结构体：</p>
<pre><code class="language-rs">use bevy::render::pass::ClearColor;
</code></pre>
<p>然后在 app 构建器增加资源：</p>
<pre><code class="language-rs">.add_resource(ClearColor(Color::rgb(0.04, 0.04, 0.04)))
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>原文中这里的规格是 2000，但是 2000 的规则放 10x10 显然太大了， 这里改成 200</p>
</div>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/moving_square_grid.mp4" type="video/mp4">
</video>
<h2 id="生成食物"><a class="header" href="#生成食物">生成食物</a></h2>
<p>现在我们的小蛇可以到处移动了，该喂点东西给它了。现在我们给 <code>Materials</code> 加一个 <code>food_materials</code> 字段：</p>
<pre><code class="language-rs">struct Materials {
    head_material: Handle&lt;ColorMaterial&gt;,
    food_material: Handle&lt;ColorMaterial&gt;, // &lt;--
}
</code></pre>
<p>然后把这个新材质加到我们的 <code>setup</code> 函数里：</p>
<pre><code class="language-rs">commands.insert_resource(Materials {
    head_material: materials.add(Color::rgb(0.7, 0.7, 0.7).into()),
    food_material: materials.add(Color::rgb(1.0, 0.0, 1.0).into()), // &lt;--
});
</code></pre>
<p>然后我们需要 <code>Duration</code> 给要创建的定时器使用，而且我们还需要 <code>random</code> 来随机分配食物的位置。先在程序里引入这些：</p>
<pre><code class="language-rs">use rand::prelude::random;
use std::time::Duration;
</code></pre>
<p>然后我们因素两个新结构体： <code>Food</code> 组件让我们知道哪个实体是食物，以及一个定时制造食物的定时器：</p>
<pre><code class="language-rs">struct Food;

struct FoodSpawnTimer(Timer);
impl Default for FoodSpawnTimer {
    fn default() -&gt; Self {
        Self(Timer::new(Duration::from_millis(1000), true))
    }
}
</code></pre>
<p>至于实现 <code>Default</code> 的原因，会在我解释下面的系统的时候说明：</p>
<pre><code>fn food_spawner(
    mut commands: Commands,
    materials: Res&lt;Materials&gt;,
    time: Res&lt;Time&gt;,
    mut timer: Local&lt;FoodSpawnTimer&gt;,
) {
    timer.0.tick(time.delta_seconds);
    if timer.0.finished {
        commands
            .spawn(SpriteComponents {
                material: materials.food_material.clone(),
                ..Default::default()
            })
            .with(Food)
            .with(Position {
                x: (random::&lt;f32&gt;() * ARENA_WIDTH as f32) as i32,
                y: (random::&lt;f32&gt;() * ARENA_HEIGHT as f32) as i32,
            })
            .with(Size::square(0.8));
    }
}
</code></pre>
<p>我们引入了局部资源概念，具体而言是 <code>timer</code> 参数。 Bevy 会看到这个参数并且实例化一个 <code>FoodSpawnTimer</code> 类型的值，用的是我们的 <code>Default</code> 实现。这会在这个系统第一次运行是发生，之后这个系统会一直重用相同的定时器。像这样使用局部资源要比手动注册资源更贴近工程化。这个定时器会一直重复，所以我们只需要调用 <code>tick</code> 函数，然后无论这个系统在定时器完成后什么时候跑，我们就随机创建一些食物。</p>
<p>你可能知道下一步是什么了，把这个系统加到应用构建器上：</p>
<pre><code class="language-rs">.add_system(food_spawner.system())
</code></pre>
<p>现在我们的程序看起来像这样：</p>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/food_spawning.mp4" type="video/mp4">
</video>
<h2 id="更像蛇的移动"><a class="header" href="#更像蛇的移动">更像蛇的移动</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/f4e6100">点击查看差异</a></p>
</blockquote>
<p>我们现在准备定时触发小蛇移动。具体说来，我们想小蛇一直在移动，无论我们是否按下按键；并且我们想要它每隔 X 秒移动一次，而不是每一帧都移动。我们会改动几个地方，所以如果你不太清楚要改动哪里，查看这一小节的差异吧。</p>
<p>首先，我们需要加一个方向枚举：</p>
<pre><code class="language-rs">#[derive(PartialEq, Copy, Clone)]
enum Direction {
    Left,
    Up,
    Right,
    Down,
}

impl Direction {
    fn opposite(self) -&gt; Self {
        match self {
            Self::Left =&gt; Self::Right,
            Self::Right =&gt; Self::Left,
            Self::Up =&gt; Self::Down,
            Self::Down =&gt; Self::Up,
        }
    }
}
</code></pre>
<p>然后把这个方向枚举加到我们的 <code>SnakeHead</code> 结构体，使得它知道应该要往哪里移动：</p>
<pre><code class="language-rs">struct SnakeHead {
    direction: Direction,
}
</code></pre>
<p>我们也得在实例化 <code>SnakeHead</code> 组件的时候给定初始方向，例如我们让它一开始往上走：</p>
<pre><code class="language-rs">.with(SnakeHead {
    direction: Direction::Up,
})
</code></pre>
<p>小蛇通常移动不是很流畅，是一种一步步来的行动。就行我们生成食物的时候，我们需要使用定时器来让系统没每隔 X秒/毫秒才跑一次。我们需要创建一个结构体来持有定时器：</p>
<pre><code class="language-rs">struct SnakeMoveTimer(Timer);
</code></pre>
<p>然后我们把它当成资源加到我们的 app 构建器：</p>
<pre><code class="language-rs">.add_resource(SnakeMoveTimer(Timer::new(
    Duration::from_millis(150. as u64),
    true,
)))
</code></pre>
<p>我们之所以不把这个定时器像生成食物的时候把定时器看成局部资源，是因为我们将会在几个系统里用上它，所以我帮你节约了一些重构的工作。因为我们需要在几个系统里使用它，我们需要创建一个新系统来触发这个定时器：</p>
<pre><code class="language-rs">fn snake_timer(time: Res&lt;Time&gt;, mut snake_timer: ResMut&lt;SnakeMoveTimer&gt;) {
    snake_timer.0.tick(time.delta_seconds);
}
</code></pre>
<p>我们也可以把这段触发逻辑直接放到 <code>snake_movement</code> 系统里，但是我比较喜欢整洁地吧它放到一个单独的系统中，因为这个定时器会用在几个地方。我们把这个系统也加到 app上：</p>
<pre><code class="language-rs">.add_system(snake_timer.system())
</code></pre>
<p>现在我们可以做方向逻辑的核心部分，也就是 <code>snake_movement</code> 系统，以下是更新后的版本：</p>
<pre><code class="language-rs">fn snake_movement(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    snake_timer: ResMut&lt;SnakeMoveTimer&gt;,
    mut heads: Query&lt;(Entity, &amp;mut SnakeHead)&gt;,
    mut positions: Query&lt;&amp;mut Position&gt;,
) {
    if let Some((head_entity, mut head)) = heads.iter_mut().next() {
        let mut head_pos = positions.get_mut(head_entity).unwrap();
        let dir: Direction = if keyboard_input.pressed(KeyCode::Left) {
            Direction::Left
        } else if keyboard_input.pressed(KeyCode::Down) {
            Direction::Down
        } else if keyboard_input.pressed(KeyCode::Up) {
            Direction::Up
        } else if keyboard_input.pressed(KeyCode::Right) {
            Direction::Right
        } else {
            head.direction
        };
        if dir != head.direction.opposite() {
            head.direction = dir;
        }
        if !snake_timer.0.finished {
            return;
        }
        match &amp;head.direction {
            Direction::Left =&gt; {
                head_pos.x -= 1;
            }
            Direction::Right =&gt; {
                head_pos.x += 1;
            }
            Direction::Up =&gt; {
                head_pos.y += 1;
            }
            Direction::Down =&gt; {
                head_pos.y -= 1;
            }
        };
    }
}
</code></pre>
<p>这里没有什么新概念，仅仅是游戏逻辑。你可能在想为什么我们需要获取拥有 <code>SankeHead</code> 组件的 <code>Entity</code>， 然后用另外一个独立的查询来获取位置， 而不是用像 <code>Query&lt;Entity, &amp;SnakeHead, &amp;mut Position&gt;</code> 这样的参数。原因在于，我们之后可能需要其他实体的位置，而分开两个查询访问相同的组件是不会允许放在 Bevy app 构建器上的。这样改了之后，你会获得一个蛇头移动的稍微……像蛇一样：</p>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/moving_snake_like.mp4" type="video/mp4">
</video>
<h2 id="加个尾巴"><a class="header" href="#加个尾巴">加个尾巴</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/7c8e2f7">点击查看差异</a></p>
</blockquote>
<p>小蛇的尾巴有点复杂。对于每蛇尾的分段，我们需要知道它下一步需要到哪里。我们准备这样实现：将这些分段放到 <code>Vec</code>，然后存储为资源。这样，当我们更新分段的位置时，我们能够迭代所有的分段并且设置每个分段的位置为前一个分段的位置。</p>
<p>我们加一个 <code>segment_material</code> 字段到我们趁手的 <code>Materials</code> 结构体：</p>
<pre><code class="language-rs">struct Materials {
    head_material: Handle&lt;ColorMaterial&gt;,
    segment_material: Handle&lt;ColorMaterial&gt;, // &lt;--
    food_material: Handle&lt;ColorMaterial&gt;,
}
</code></pre>
<p>老调重弹，把 <code>segment_material</code> 加到 <code>setup</code> 中：</p>
<pre><code class="language-rs">commands.insert_resource(Materials {
    head_material: materials.add(Color::rgb(0.7, 0.7, 0.7).into()),
    segment_material: materials.add(Color::rgb(0.3, 0.3, 0.3).into()), // &lt;--
    food_material: materials.add(Color::rgb(1.0, 0.0, 1.0).into()),
});
</code></pre>
<p>然后一个给蛇身分段的组件：</p>
<pre><code class="language-rs">struct SnakeSegment;
</code></pre>
<p>然后我们再加上我们说到的，用来存储分段列表的资源：</p>
<pre><code class="language-rs">#[derive(Default)]
struct SnakeSegments(Vec&lt;Entity&gt;);
</code></pre>
<p>再把它作为资源加到我们的 app 上：</p>
<pre><code class="language-rs">.add_resource(SnakeSegments::default())
</code></pre>
<p>我们我们需要从几个地方生成分段（当你吃食物或者你初始化小蛇的时候），我们需要先创建一个辅助函数：</p>
<pre><code class="language-rs">fn spawn_segment(
    commands: &amp;mut Commands,
    material: &amp;Handle&lt;ColorMaterial&gt;,
    position: Position,
) -&gt; Entity {
    commands
        .spawn(SpriteComponents {
            material: material.clone(),
            ..SpriteComponents::default()
        })
        .with(SnakeSegment)
        .with(position)
        .with(Size::square(0.65))
        .current_entity()
        .unwrap()
}
</code></pre>
<p>这看上去非常像我们生成 <code>SnakeHead</code> 的函数，但是替换了 <code>SnakeHead</code> 组件，我们用的是 <code>SnakeSegment</code> 组件。这里要说的新知识点，就是我们最后通过 <code>current_entity</code> 函数，获取了生成的 <code>Entity</code> （其实只是个 id），然后将它返回给调用者以便使用它。现在，我们需要修改我们的游戏配置函数。并非只是生成一个蛇头，它现在要生成一个蛇身的分段：</p>
<pre><code class="language-rs">fn spawn_snake(
    mut commands: Commands,
    materials: Res&lt;Materials&gt;,
    mut segments: ResMut&lt;SnakeSegments&gt;,
) {
    segments.0 = vec![
        commands
            .spawn(SpriteComponents {
                material: materials.head_material.clone(),
                ..Default::default()
            })
            .with(SnakeHead {
                direction: Direction::Up,
            })
            .with(SnakeSegment)
            .with(Position { x: 3, y: 3 })
            .with(Size::square(0.8))
            .current_entity()
            .unwrap(),
        spawn_segment(
            &amp;mut commands,
            &amp;materials.segment_material,
            Position { x: 3, y: 2 },
        ),
    ];
}
</code></pre>
<p>我们第一个分段是头部，现在我们多加了一个 <code>with(SnakeSegment)</code>。第二个分段来自我们的 <code>spawn_segment</code> 函数。我们现在得到了一条小小的尾巴：</p>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/detached_tail.mp4" type="video/mp4">
</video>
<h2 id="让尾巴跟着小蛇活动"><a class="header" href="#让尾巴跟着小蛇活动">让尾巴跟着小蛇活动</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/2f57b9b">点击查看差异</a></p>
</blockquote>
<p>正如我记得那样，蛇尾没有脱离蛇头，是贪吃蛇游戏中重要的一部分。我们来看看，我们可以怎么修改 <code>snake_movement</code> 函数，来更接近原汁原味的游戏。首先要做的事把 <code>SnakeSegments</code> 资源到 <code>snake_movement</code> 函数上：</p>
<pre><code class="language-rs">fn snake_movement(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    snake_timer: ResMut&lt;SnakeMoveTimer&gt;,
    segments: ResMut&lt;SnakeSegments&gt;, // &lt;--
    mut heads: Query&lt;(Entity, &amp;mut SnakeHead)&gt;,
    mut positions: Query&lt;&amp;mut Position&gt;,
</code></pre>
<p>现在，直接在最前面的 <code>if let</code> 后面，我们加上所有分段的位置（当然，不要忘了蛇头的位置）：</p>
<pre><code class="language-rs">let segment_positions = segments
    .0
    .iter()
    .map(|e| *positions.get_mut(*e).unwrap())
    .collect::&lt;Vec&lt;Position&gt;&gt;();
</code></pre>
<p>然后我们要做的是在 <code>if let</code> 的末尾迭代蛇身分段（跳过蛇头，因为我们已经通过用户输入更新了位置），然后让每个分段的位置都变成前一个分段的。例如，第一个蛇身分段设置为当前蛇头（更新前）的位置，第二段的设置为第一段的。</p>
<pre><code class="language-rs">segment_positions
    .iter()
    .zip(segments.0.iter().skip(1))
    .for_each(|(pos, segment)| {
        *positions.get_mut(*segment).unwrap() = *pos;
    });
</code></pre>
<p>现在我们的游戏看起来应该像这样：</p>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/tail_following.mp4" type="video/mp4">
</video>
<h2 id="小蛇成长"><a class="header" href="#小蛇成长">小蛇成长</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/0533569">点击查看差异</a></p>
</blockquote>
<p>小蛇已经饿坏了。我们现在需要家一个系统来让小蛇猎食：</p>
<pre><code class="language-rs">fn snake_eating(
    mut commands: Commands,
    snake_timer: ResMut&lt;SnakeMoveTimer&gt;,
    mut growth_events: ResMut&lt;Events&lt;GrowthEvent&gt;&gt;,
    food_positions: Query&lt;With&lt;Food, (Entity, &amp;Position)&gt;&gt;,
    head_positions: Query&lt;With&lt;SnakeHead, &amp;Position&gt;&gt;,
) {
    if !snake_timer.0.finished {
        return;
    }
    for head_pos in head_positions.iter() {
        for (ent, food_pos) in food_positions.iter() {
            if food_pos == head_pos {
                commands.despawn(ent);
                growth_events.send(GrowthEvent);
            }
        }
    }
}
</code></pre>
<p>只是迭代所有的食物位置，来看他们是不是和蛇头共享一个位置，如果是这样，我们就用 <code>despawn</code> 者趁手的函数移除食物，然后触发一个 <code>GrowthEvent</code>。我们来创建这个结构体：</p>
<pre><code class="language-rs">struct GrowthEvent;
</code></pre>
<p>使用事件是个新概念。你可以在系统间发送或接受事件，他们可以是任意类型的结构体，使得你可以在事件里包括任何你需要发送的数据。例如，你可能有一个系统发送跳跃事件，然后一个独立的系统来处理他们。在我们的这个案例中，我们需要一个系统来发送成长事件，以及一个成长系统来处理它们。你需要注册事件，就像我们对资源和系统做的那样：</p>
<pre><code class="language-rs">.add_event::&lt;GrowthEvent&gt;()
</code></pre>
<p>然后在这里我们也加上 <code>snake_eating</code> 系统：</p>
<pre><code class="language-rs">.add_system(snake_eating.system())
</code></pre>
<p>现在小蛇应该能够猎食了。但是小蛇现在就像个黑洞，吃多少也不长大。在思考成长这事时，需要注意我们需要知道最后的分段移动前在哪里，因为那里是新的分段成长的位置。现在我们来创建一个新资源：</p>
<pre><code class="language-rs">#[derive(Default)]
struct LastTailPosition(Option&lt;Position&gt;);
</code></pre>
<p>然后在 app 构建器上：</p>
<pre><code class="language-rs">.add_resource(LastTailPosition::default())
</code></pre>
<p>我们也要对 <code>snake_movement</code> 系统做一点小修改，来更新 <code>LastTailPosition</code> 资源。首先先把这个资源加到参数中：</p>
<pre><code class="language-rs">fn snake_movement(
    // ...
    mut last_tail_position: ResMut&lt;LastTailPosition&gt;, // &lt;--
    // ...
</code></pre>
<p>然后就是给这个资源分配最后的一个分段的位置。这段代码放在我们迭代过了 <code>segment_positions</code> 之后：</p>
<pre><code class="language-rs">last_tail_position.0 = Some(*segment_positions.last().unwrap()); // &lt;--
</code></pre>
<p>之后，小蛇成长的函数就很清晰了：</p>
<pre><code class="language-rs">fn snake_growth(
    mut commands: Commands,
    last_tail_position: Res&lt;LastTailPosition&gt;,
    growth_events: Res&lt;Events&lt;GrowthEvent&gt;&gt;,
    mut segments: ResMut&lt;SnakeSegments&gt;,
    mut growth_reader: Local&lt;EventReader&lt;GrowthEvent&gt;&gt;,
    materials: Res&lt;Materials&gt;,
) {
    if growth_reader.iter(&amp;growth_events).next().is_some() {
        segments.0.push(spawn_segment(
            &amp;mut commands,
            &amp;materials.segment_material,
            last_tail_position.0.unwrap(),
        ));
    }
}
</code></pre>
<p>以及追加系统：</p>
<pre><code class="language-rs">.add_system(snake_growth.system())
</code></pre>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/growing.mp4" type="video/mp4">
</video>
<h2 id="撞墙或者咬尾巴"><a class="header" href="#撞墙或者咬尾巴">撞墙（或者咬尾巴）</a></h2>
<blockquote>
<p><a href="https://github.com/marcusbuffett/bevy_snake/commit/bd2b307">点击查看差异</a></p>
</blockquote>
<p>现在我们来增加撞墙和咬尾巴来触发游戏结束（game over）。我们使用一个新事件，就像我们在“小蛇成长小节”中那样：</p>
<pre><code class="language-rs">struct GameOverEvent;
</code></pre>
<p>并把它注册到 app 构建器上：</p>
<pre><code class="language-rs">.add_event::&lt;GameOverEvent&gt;()
</code></pre>
<p>在我们的 <code>snake_movement</code> 系统中，我们想要访问 “游戏结束” 事件，使得我们能够发送事件：</p>
<pre><code class="language-rs">fn snake_movement(
    // ...
    mut game_over_events: ResMut&lt;Events&lt;GameOverEvent&gt;&gt;, // &lt;--
    // ...
) {
</code></pre>
<p>我们先关注在撞墙事件上面。把这部分代码放到 <code>match &amp;head.direction {</code> 后面：</p>
<pre><code class="language-rs">if head_pos.x &lt; 0
    || head_pos.y &lt; 0
    || head_pos.x as u32 &gt;= ARENA_WIDTH
    || head_pos.y as u32 &gt;= ARENA_HEIGHT
{
    game_over_events.send(GameOverEvent);
}
</code></pre>
<p>好了，现在我们的 <code>snake_movement</code> 系统可以发送 “游戏结束” 事件了，我们再来创建一个系统来监听这些事件：</p>
<pre><code class="language-rs">fn game_over(
    mut commands: Commands,
    mut reader: Local&lt;EventReader&lt;GameOverEvent&gt;&gt;,
    game_over_events: Res&lt;Events&lt;GameOverEvent&gt;&gt;,
    materials: Res&lt;Materials&gt;,
    segments_res: ResMut&lt;SnakeSegments&gt;,
    food: Query&lt;With&lt;Food, Entity&gt;&gt;,
    segments: Query&lt;With&lt;SnakeSegment, Entity&gt;&gt;,
) {
    if reader.iter(&amp;game_over_events).next().is_some() {
        for ent in food.iter().chain(segments.iter()) {
            commands.despawn(ent);
        }
        spawn_snake(commands, materials, segments_res);
    }
}
</code></pre>
<p>这里有个很酷的点: 我们可以直接使用 <code>spawn_snake</code> 函数，现在它既是一个系统，也是一个辅助函数了。</p>
<p>最后一个修改点，就是我们得让小蛇咬到尾巴的时候也会触发 “游戏结束” 事件。在 <code>snake_movement</code> 系统中，在我们检查完边界的部分后添加：</p>
<pre><code class="language-rs">if segment_positions.contains(&amp;head_pos) {
    game_over_events.send(GameOverEvent);
}
</code></pre>
<p>最后，我们的成果：</p>
<video controls="" loop="" muted="" playsinline="" class="bevy_img">
    <source src="https://mbuffett.com/bevy_snake/new_gifs/game_over.mp4" type="video/mp4">
</video>

                    </main>

                    <hr>
                    <script src="https://utteranc.es/client.js"
                            repo="huangjj27/blog-gitment"
                            issue-term="title"
                            label="utterances"
                            theme="github-light"
                            crossorigin="anonymous"
                            async>
                    </script>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="interview.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="rust-safe-apps-51.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="interview.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="rust-safe-apps-51.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

    </body>
</html>
